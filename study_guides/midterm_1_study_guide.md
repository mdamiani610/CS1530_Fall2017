# CS1530 - Study Guide - Midterm 1

This covers all the material from the beginning of the class to the last lecture before the midterm.  Specifically, it will cover the following topics.

* The SDLC - Understand what each phase is, what order they come in, what each involves
  * Is the SDLC as pictured an accurate view of modern software development?
* The Iron Triangle of Project Management
  * What does it consist of?
  * Understand/analyze trade-offs
  * Are trade-offs always linear?
* Understand how to calculate the number of communications pathways as the number of people increase
  * Know Brooks' Law and be able to explain
* Why is estimating software effort/time difficult?
* Understand requirements vs design constraints
* Understand functional vs non-functional requirements (quality attributes)
* Understand implicit vs explicit requirements
* Technical vs non-technical considerations
* Why do projects fail?
  * Lack of user input/involvement
  * Incomplete requirements/specifications
  * Changing requirements/specifications
* Failures by phase of software
  * Most common in coding phase, but book recommends focusing on requirements phase.. why?
* Failures by size of software
  * Larger software -> bigger chance of failure.  Why?
* What is a use case?
* What is an actor?
* Software methodologies - what are they? which one is "best"?
* Heavyweight vs Lightweight methodologies - understand trade-offs
* Understand and know trade-offs of specific methodologies described in slides:
  * Cowboy coding
  * Waterfall
  * Spiral
  * Cleanroom
  * Iterative and Incremental
  * RAD
  * Agile / XP
  * Agile / Crystal
  * Agile / Scrum
* What is CMMI?  What are the levels of CMMI?
* What are the main differences between traditional methodologies and Agile methodologies?
* Understand the basic philosophy of Agile (the Agile Manifesto)
* Understand Agile / Scrum in-depth
  * User stories (Connextra template, how are they different from "traditional" requirements?
  * Product backlog
  * Sprints
  * Story points
  * Tasks
  * Sprint planning
  * Sprint review
  * Retrospectives
  * Standups
  * Burndown charts
  * Velocity
  * Kaizen
* What is an SRS?  What does it consist of and what does it not consist of?
* Phases of requirements engineering
  * Elicitation
  * Documentation / definition
  * Specification
  * Prototyping
  * Analysis
  * Review and validation
  * Agreement and acceptance
* Understand high-level vs low-level (detailed) requirements elicitation
* Analytical hierarchy process - know what it is, but you do not need to memorize the calculations
  * Benefits / drawbacks of this approach?
* Requirements traceability - what is it and why do we need it?
* Types of traceability
  * Backward-from
  * Forward-from
  * Backward-to
  * Forward-to
* What does it mean to sign off on requirements?
* Phases of design
  * Architectural design phase
  * Detailed design phase
  * What is BDUF?
  * How are these different in Agile vs traditional ("BDUF") methodologies?
* What is software architecture?
* Do all systems have an architecture?
* Can you have multiple architectures in one system?
* Views of a software architecture
  * Logical view
  * Process view 
  * Subsystem decomposition view
  * Physical architecture view
* Know architectural styles and when they would be useful / not useful
  * Pipe-and-filter
  * Event-driven
  * Client-server
  * Distributed
  * Layered
  * MVC
  * Big ball of mud
* Architectural tactics - what are they?
* Reference architecture - what is it?
* Functional decomposition - what is it?
* Complexity metrics - know what they are, general ideas, benefits/drawbacks
  * Halstead complexity metric - you do not need to know calculations
  * McCabe's cyclomatic complexity - be able to calculate using simple if/then conditionals
  * Henry-Kafura information flow - calculate fan-in, fan-out, structural complexity, system complexity
  * Card-Glass system complexity - you do not need to know calculation
* Fan-in vs fan-out
* Cohesion 
  * Coincidental
  * Logical
  * Temporal
  * Procedural
  * Communicational
  * Sequential
  * Functional
* Coupling and coupling measures
  * Content coupling
  * Common coupling
  * Control coupling
  * Stamp coupling
  * Data coupling
* Basics of UI design - the "Golden Rules"
  * Place the user in control
  * Reduce the user's memory load
  * Design consistent user interface
* Usability evaluation
* Project management - know the POMA activities
  * Planning
  * Organizing
  * Monitoring
  * Adjusting
* Know how to do Lorenz-Kidd OO Estimation (you WILL need to know the formula for this)
* Understand work breakdown structure and be able to make one
* Understand what earned value is - you do NOT need to calculate yourself
* Programming style and guidelines
* Performance optimization
  * When to do it?
* What is refactoring?
  * You may refactor some code
* Code re-use - benefits/drawbacks



